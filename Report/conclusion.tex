\section{Conclusions}
\label{sec:conclusion}
In the preceding sections we compared the performance of SQLite and PostgreSQL on two benchmarks, TPC-H and SSB. We observed that SQLite was slow in most of the cases but it did perform almost as same and even better in some cases. We can attribute this performance difference between the two databases to the difference in the architecture and the use-case for each in different scenarios.

PostgreSQL follows the client/server architecture whereas SQLite is file based (embedded). Although PostgreSQL has more complex architecture but it performs efficiently in most cases. Also, the benchmarks we used TPC-H and SSB are for decision support for business and data warehouse respectively which is more suited to the use-case for PostgreSQL, which also explains its better performance in these benchmarks. SQLite~\cite{ref:compare} is light-weight and suited for applications like IoT, embedded devices, low-medium traffic websites, etc. 

When we look at the difference in their query plans we can see that the index scan that is used by SQLite in most cases becomes expensive as the selectivity increases. Also, the current implementation of SQLite uses only loop joins, i.e, joins are implemented as nested loops which also add to this overhead most of the time.

PostgreSQL does a sequential full scans followed by hash-joins in most cases. In comparision to nested loop joins, hash-joins are better which is evident from the better performance of PostgreSQL in most cases. It only performs worse in cases where the selectivity is low.
 
